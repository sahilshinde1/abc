		Lex File
------------------------------------------------------------------------------------
%{

#include "y.tab.h"

extern int yylval;
%}

VAR [A-Za-z]
DIGIT [0-9]
%%
[ \t\n]    
while				{return WHILE;}
{VAR}({VAR}|{DIGIT})*	{return ID;}
{DIGIT}+             	{yylval=atoi(yytext);return NUM;}
.                 	{return yytext[0];}
%%
------------------------------------------------------------------------------------
	Yacc File
------------------------------------------------------------------------------------
%{
#include <stdio.h>
#include <stdlib.h>
#include<ctype.h>
char stack[50][50];
extern char *yytext;
char temp[20];
int top=0;
int tempcount=0;
int lablecount=0;
int position=0;
int numb,flag=0;
char number[10];
%}

%token ID NUM WHILE
%right '='
%left '+' '-'
%left '*' '/'
%left UMINUS

%%

S 	: WHILE '('E')'{fun1();}'{'E {fun2();}';''}'

  	;
 E	: T '=' {push();} E{generate_equal();}
  	| E '+' {push();} E{generate();}
  	| E '-' {push();} E{generate();}
  	| E '*' {push();} E{generate();}
 	| E '/' {push();} E{generate();}
  	| '(' E ')'
  	| '-'{push();} E{generate_minus();} %prec UMINUS
  	| T
  	| NUM{numb=$1;push(numb);}
  	;
T 	: ID {push(yytext);}
  	;
%%

main(){
	printf("\nEnter the expression: ");
	yyparse();
}

generate(){
	if(flag==0){
		printf("\nL%d:t%d = %s %s %s",lablecount++,tempcount,stack[top-3],stack[top-2],stack[top-1]);
  		flag=1;
  	}
	else
		printf("\nt%d = %s %s %s",tempcount,stack[top-3],stack[top-2],stack[top-1]);
		
  	top=top-3;
	strcpy(stack[top],"t");
	sprintf(temp,"%d",tempcount);
	strcat(stack[top],temp);
	tempcount++;
}
generate_minus(){
	printf("\nt%d = -%s",tempcount,stack[top]);
	top--;
	strcpy(stack[top],"t");
	sprintf(temp,"%d",tempcount);
	strcat(stack[top],temp);
	tempcount++;
}
generate_equal(){
	printf("\n%s = %s",stack[top-3],stack[top-1]);
 	top=top-3;
}

fun1(){
	printf("\nt%d = not %s",tempcount,stack[top]);
	printf("\nif t%d goto L%d",tempcount++,lablecount);
}

fun2(){
	printf("\ngoto L%d",lablecount-1);
	printf("\nL%d: ",lablecount);
	exit(0);
}
push(char operator[20]){
	strcpy(stack[top++],operator);
}

int yyerror (char *msg){

	return fprintf (stderr, "YACC: %s\n", msg);

}


int yywrap(){
}        
------------------------------------------------------------------------------------
		Output
------------------------------------------------------------------------------------
Enter the expression: while (a+b){c+d;} 

L0:t0 = a + b
t1 = not t0
if t1 goto L1
t2 = c + d
goto L0
L1:
------
		Lex file
------------------------------------------------------------------------------------
%{

#include "y.tab.h"
extern int yylval;
%}

VAR [A-Za-z]
DIGIT [0-9]
%%
[ \t\n]
if				{return IF;}
then				{return THEN;}
else				{return ELSE;}
{VAR}({VAR}|{DIGIT})*	{return ID;}
{DIGIT}+             	{return NUM;}
.                 	{return yytext[0];}
%%
------------------------------------------------------------------------------------
		Yacc file
------------------------------------------------------------------------------------
%{
#include <stdio.h>
#include <stdlib.h>
#include<ctype.h>
char stack[50][50];
extern char *yytext;
char temp[20];
int top=0;
int tempcount=0;
int lablecount=0;
int numb;
char number[10];
%}

%token ID NUM IF THEN ELSE 
%right '='
%left '+' '-'
%left '*' '/'
%left UMINUS

%%
S	: IF '(' E ')'{fun1();} THEN E ';'{fun2();} ELSE E ';'{fun3();}
	;
E	: T '=' {push();} E{generate_equal();}
  	| E '+' {push();} E{generate();}
  	| E '-' {push();} E{generate();}
  	| E '*' {push();} E{generate();}
 	| E '/' {push();} E{generate();}
  	| '(' E ')'
  	| '-'{push();} E{generate_minus();} %prec UMINUS
  	| T
  	| NUM{numb=$1;push();}
  	;
T 	: ID {push();}
  	;
%%

main(){
	printf("\nEnter the expression: ");
	yyparse();
}

generate(){
  	printf("\nt%d = %s %s %s",tempcount,stack[top-3],stack[top-2],stack[top-1]);
  	top=top-3;
	strcpy(stack[top],"t");
	sprintf(temp,"%d",tempcount);
	strcat(stack[top],temp);
	tempcount++;
}
generate_minus(){
	printf("\nt%d = -%s",tempcount,stack[top]);
	top--;
	strcpy(stack[top],"t");
	sprintf(temp,"%d",tempcount);
	strcat(stack[top],temp);
	tempcount;
}
generate_equal(){
	printf("\n%s = %s",stack[top-3],stack[top-1]);
 	top=top-3;
}

fun1(){
	printf("\nt%d = not %s",tempcount,stack[top]);
	printf("\nif t%d goto L%d",tempcount++,lablecount++);
}

fun2(){
	printf("\ngoto L%d",lablecount);
	printf("\nL%d: ",lablecount-1);
	lablecount++;
}

fun3()
{
	printf("\nL%d: ",lablecount-1);
	exit(0);
}

push(){
	strcpy(stack[top++],yytext);
}

int yyerror (char *msg){

	return fprintf (stderr, "YACC: %s\n", msg);

}


int yywrap(){
}        
------------------------------------------------------------------------------------
		Output
------------------------------------------------------------------------------------
Enter the expression: if (a+b)then c+d ; else p+q;

t0 = a + b
t1 = not t0
if t1 goto L0
t2 = c + d
goto L1
L0: 
t3 = p + q


----
		Lex File
------------------------------------------------------------------------------------
%{

#include "y.tab.h"

extern int yylval;
%}

VAR [A-Za-z]
DIGIT [0-9]
%%
[ \t\n]    
switch			{return SWITCH;}
case				{return CASE;}
break				{return BREAK;}
default			{return DEFAULT;}
{VAR}({VAR}|{DIGIT})*	{return ID;}
{DIGIT}+             	{return NUM;}
.                 	{return yytext[0];}
%%
------------------------------------------------------------------------------------
	Yacc File
------------------------------------------------------------------------------------
%{
#include <stdio.h>
#include <stdlib.h>
#include<ctype.h>
char stack[50][50];
extern char *yytext;
char temp[20];
int top=0;
int tempcount=0;
int lablecount=0;
int numb;
char number[10];
%}

%token ID NUM SWITCH CASE BREAK DEFAULT
%right '='
%left '+' '-'
%left '*' '/'
%left UMINUS

%%
S 	: SWITCH '('E')''{' CASE N {fun1();}':' E ';' BREAK {fun2();}';'
			DEFAULT ':' E {fun3();}';''}'

  	;
 E	: T '=' {push();} E{generate_equal();}
  	| E '+' {push();} E{generate();}
  	| E '-' {push();} E{generate();}
  	| E '*' {push();} E{generate();}
 	| E '/' {push();} E{generate();}
  	| '(' E ')'
  	| '-'{push();} E{generate_minus();} %prec UMINUS
  	| T
  	| NUM{numb=$1;push();}
  	;
T 	: ID {push(yytext);}
  	;
N	:NUM{numb=$1;push();}
	;
%%

main(){
	printf("\nEnter the expression: ");
	yyparse();
}

generate(){
  	printf("\nt%d = %s %s %s",tempcount,stack[top-3],stack[top-2],stack[top-1]);
  	top=top-3;
	strcpy(stack[top],"t");
	sprintf(temp,"%d",tempcount);
	strcat(stack[top],temp);
	top++;
	tempcount++;
}

generate_minus(){
	printf("\nt%d = -%s",tempcount,stack[top]);
	top--;
	strcpy(stack[top],"t");
	sprintf(temp,"%d",tempcount);
	strcat(stack[top],temp);
	tempcount;
}
generate_equal(){
	printf("\n%s = %s",stack[top-3],stack[top-1]);
 	top=top-3;
}

fun1(){
	printf("\nif %s is not equal to %s goto L%d",stack[top-1],stack[top-2],lablecount++);
	top--;
}
fun2(){
	printf("\ngoto L%d",lablecount);  //for break
	printf("\nL%d:",lablecount-1); 		//for default 
}

fun3(){
	printf("\nL%d:",lablecount);
	exit(0);
}

push(){
	strcpy(stack[top++],yytext);
}

int yyerror (char *msg){

	return fprintf (stderr, "YACC: %s\n", msg);

}


int yywrap(){
} 
------------------------------------------------------------------------------------
		Output
-------------------------------------------------------------------------------------
Enter the expression: switch (a+b) { case 1:c+d ; break; default: p+q;}

t0 = a + b
if 1 is not equal to t0 goto L0
t1 = c + d
goto L1
L0:
t2 = p + q
L1: 